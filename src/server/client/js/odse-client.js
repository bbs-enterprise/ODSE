// Generated by CoffeeScript 1.10.0
(function() {
  var ErrorEvent, Event, EventEmitter, Iterator,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.odse = {};


  /*
    NOTE: The following is extracted from the official 'evolvenode' module. Try not to modify anything here
    since on later releases, these classes will be loaded from evolvenode module directly.
    Everything is classically written, so you can just subclass and hook if you need to.
   */


  /*
    @class Iterator
    @purpose Asynchronous iterator for a list with flow control.
   */

  Iterator = (function() {
    function Iterator(list1, forEachFn1) {
      this.list = list1;
      this.forEachFn = forEachFn1;
      this.then = bind(this.then, this);
      this.next = bind(this.next, this);
      this.index = 0;
      this.hasIterationEnded = false;
      this.next();
    }

    Iterator.prototype.next = function() {
      var cb, oldIndex;
      if (this.index === this.list.length) {
        this.hasIterationEnded = true;
        if (this.finalFn && this.hasIterationEnded) {
          cb = this.finalFn;
          this.finalFn = null;
          return cb();
        }
      } else {
        oldIndex = this.index;
        this.index++;
        return this.forEachFn(this.next, oldIndex, this.list[oldIndex]);
      }
    };

    Iterator.prototype.then = function(finalFn) {
      var cb;
      this.finalFn = finalFn;
      if (this.finalFn && this.hasIterationEnded) {
        cb = this.finalFn;
        this.finalFn = null;
        return cb();
      }
    };

    return Iterator;

  })();

  window.odse.Iterator = window.odse.Iterator;


  /*
    @window.odse.iterate
   */

  window.odse.iterate = function(list, forEachFn) {
    return new window.odse.Iterator(list, forEachFn);
  };

  window.odse.iterate = window.odse.iterate;


  /*
    NOTE: The following is extracted from the official 'evolvenode' module. Try not to modify anything here
    since on later releases, these classes will be loaded from evolvenode module directly.
    Everything is classically written, so you can just subclass and hook if you need to.
   */


  /*
    @class EventEmitter
   */

  EventEmitter = (function() {
    function EventEmitter() {
      this._EventClassMap = {};
      this.register(window.odse.ErrorEvent, 'error');
    }

    EventEmitter.prototype.__getProperEventName = function(eventArg) {
      if (typeof eventArg === 'object' && eventArg.prototype instanceof window.odse.Event) {
        return eventArg.prototype.name;
      } else if (typeof eventArg === 'string') {
        return eventArg;
      } else {
        throw new Error('Type Mismatch. Expected <window.odse.Event> or <string>');
      }
    };

    EventEmitter.prototype.isRegistered = function(name) {
      return name in this._EventClassMap;
    };

    EventEmitter.prototype.register = function(EventClass, name) {
      if (name == null) {
        name = null;
      }
      if (!name) {
        name = EventClass.prototype.name;
      }
      if (this.isRegistered(name)) {
        throw new Error("window.odse.Event <" + name + "> is already registered");
      }
      this._EventClassMap[name] = {
        earlyHandlerList: [],
        lateHandlerList: [],
        handlerList: [],
        EventClass: EventClass
      };
      return this;
    };

    EventEmitter.prototype.addEventHandler = function() {
      var args, eventArg, executionContext, handlerFn, modifier, name;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (args.length === 2) {
        eventArg = args[0], handlerFn = args[1];
        modifier = null;
      } else if (args.length === 3) {
        eventArg = args[0], modifier = args[1], handlerFn = args[2];
      } else if (args.length === 4) {
        eventArg = args[0], modifier = args[1], executionContext = args[2], handlerFn = args[3];
      }
      if (executionContext) {
        handlerFn = handlerFn.bind(executionContext);
      } else {
        handlerFn = handlerFn.bind(this);
      }
      if (typeof handlerFn !== 'function') {
        throw new Error('Type Mismatch. Expected <function>');
      }
      name = this.__getProperEventName(eventArg);
      if (!this.isRegistered(name)) {
        throw new Error("window.odse.Event <" + name + "> is not registered and so can not be listened to.");
      }
      if (modifier === null) {
        this._EventClassMap[name].handlerList.push(handlerFn);
      } else if (modifier === 'late') {
        this._EventClassMap[name].lateHandlerList.push(handlerFn);
      } else if (modifier === 'early') {
        this._EventClassMap[name].earlyHandlerList.push(handlerFn);
      } else {
        throw new Error('Unknown Modifier');
      }
      return this;
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addEventHandler;

    EventEmitter.prototype.removeEventHandler = function(eventArg, handlerFn) {
      var name, pos;
      if (handlerFn == null) {
        handlerFn = null;
      }
      name = this.__getProperEventName(eventArg);
      if (!this.isRegistered(name)) {
        throw new Error("window.odse.Event <" + name + "> is not registered and so nothing to remove listener from");
      }
      if (handlerFn === null) {
        return this._EventClassMap[name].handlerList = {};
      } else {
        if (typeof handlerFn !== 'function') {
          throw new Error('Type Mismatch. Expected <function>');
        }
        if ((pos = this._EventClassMap[name].handlerList.indexOf(handlerFn)) > -1) {
          return this._EventClassMap[name].handlerList.splice(pos, 1);
        } else {
          throw new Error('handler does not exist and so can not be removed');
        }
      }
    };

    EventEmitter.prototype.off = EventEmitter.prototype.removeEventHandler;

    EventEmitter.prototype.once = function(eventArg, handlerFn) {
      var called, fn;
      called = false;
      fn = (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if (called) {
            args[0].next();
          } else {
            handlerFn.apply(_this, args);
          }
          return called = true;
        };
      })(this);
      return this.on(eventArg, fn);
    };

    EventEmitter.prototype.getEventHandlerList = function(eventArg) {
      var name;
      name = this.__getProperEventName(eventArg);
      if (!this.isRegistered(name)) {
        throw new Error("window.odse.Event <" + name + "> is not registered and so can not be emitted.");
      }
      return [].concat(this._EventClassMap[name].earlyHandlerList, this._EventClassMap[name].handlerList, this._EventClassMap[name].lateHandlerList);
    };

    EventEmitter.prototype.emit = function(eventArg, data, completionHandler) {
      var eventObject, name;
      if (data == null) {
        data = null;
      }
      if (completionHandler == null) {
        completionHandler = null;
      }
      name = this.__getProperEventName(eventArg);
      if (!this.isRegistered(name)) {
        throw new Error("window.odse.Event <" + name + "> is not registered and so can not be emitted.");
      }
      eventObject = new this._EventClassMap[name].EventClass({
        origin: this,
        target: this,
        data: data,
        name: name
      });
      if (completionHandler) {
        eventObject.setCompletionCallback(completionHandler);
      }
      eventObject.dispatch();
      return this;
    };

    return EventEmitter;

  })();


  /*
    @class Event
   */

  Event = (function(superClass) {
    extend(Event, superClass);

    Event.isSequencial = true;

    Event.isAsync = true;

    Event.fallbackHandler = null;

    Event.prototype.name = 'window.odse.Event';

    function Event(arg) {
      var data, error, ex, handlerList, name, ref;
      ref = arg != null ? arg : {}, this.origin = ref.origin, this.target = ref.target, data = ref.data, handlerList = ref.handlerList, name = ref.name;
      this.reset = bind(this.reset, this);
      this.next = bind(this.next, this);
      this.dispatch = bind(this.dispatch, this);
      this.stopPropagation = bind(this.stopPropagation, this);
      Event.__super__.constructor.apply(this, arguments);
      if (!((this.origin === null) || (typeof this.origin === 'object' && this.origin instanceof window.odse.EventEmitter))) {
        throw new Error('Type Mismatch. Expected origin to be <null> or <window.odse.EventEmitter>');
      }
      if (!((this.target === null) || (typeof this.target === 'object' && this.target instanceof window.odse.EventEmitter))) {
        throw new Error('Type Mismatch. Expected target to be <null> or <window.odse.EventEmitter>');
      }
      if (this.origin && !this.target) {
        this.target = this.origin;
      }
      if (this.target && !this.origin) {
        this.origin = this.target;
      }
      this.storedData = data;
      this.storedData || (this.storedData = {});
      if (typeof name === 'string') {
        this.name = name;
      } else {
        try {
          if (this.name === 'window.odse.Event' && this.constructor.name !== 'window.odse.Event') {
            this.name = this.constructor.name;
          }
        } catch (error) {
          ex = error;
        }
      }
      if (typeof handlerList === 'object' && Array.isArray(handlerList)) {
        this._handlerList = handlerList;
      } else {
        if (!this.target) {
          throw new Error('Insufficient Information to trigger event');
        }
        this._handlerList = this.target.getEventHandlerList(this.name);
      }
      if (this._handlerList.length === 0 && this.constructor.fallbackHandler !== null) {
        this._handlerList = [this.constructor.fallbackHandler];
      }
      if (!(typeof this._handlerList === 'object' && Array.isArray(this._handlerList))) {
        throw new Error('Type Mismatch. Expected <array>');
      }
      if (typeof this.storedData !== 'object') {
        throw new Error('Type Mismatch. Expected <object>');
      }
      this._handlerIndex = 0;
      this._completionCallback = null;
      this.hasPropagationStopped = false;
      this.isDispatched = false;
      this.path = [this.target];
    }

    Event.prototype.setCompletionCallback = function(fn) {
      if (typeof fn !== 'function') {
        throw new Error('Type Mismatch. Expected <function>');
      }
      this._completionCallback = fn;
      return this;
    };

    Event.prototype._invokeCompletionCallback = function() {
      var cbfn;
      if (!this._completionCallback) {
        return false;
      }
      cbfn = this._completionCallback;
      this._completionCallback = null;
      return cbfn(this);
    };

    Event.prototype.stopPropagation = function() {
      this.hasPropagationStopped = true;
      return this;
    };

    Event.prototype.dispatch = function() {
      var handlerFn, i, len, ref;
      if (this.isDispatched) {
        throw new Error('window.odse.Event is already dispatched');
      }
      this.isDispatched = true;
      if (this.constructor.isSequencial && this.constructor.isAsync) {
        return this.next();
      } else {
        ref = this._handlerList;
        for (i = 0, len = ref.length; i < len; i++) {
          handlerFn = ref[i];
          handlerFn(this);
        }
        return this._invokeCompletionCallback();
      }
    };

    Event.prototype.next = function() {
      var handlerFn;
      if (!this.constructor.isAsync) {
        throw new Error('next() is available only during Async Events');
      }
      if (!this.isDispatched) {
        throw new Error('next() can only be called after the event is dispatched');
      }
      if (!this.constructor.isSequencial) {
        return false;
      }
      if (this._handlerList.length === this._handlerIndex || this.hasPropagationStopped) {
        this._invokeCompletionCallback();
        return;
      }
      handlerFn = this._handlerList[this._handlerIndex++];
      handlerFn(this);
    };

    Event.prototype.reset = function() {
      this._handlerIndex = 0;
      return this;
    };

    Event.prototype.delegate = function(arg, postDelegationHandler) {
      var handlerList, name, ref, replacementCompletionHandler, target;
      ref = arg != null ? arg : {}, target = ref.target, name = ref.name, handlerList = ref.handlerList;
      if (postDelegationHandler == null) {
        postDelegationHandler = null;
      }
      if (!(typeof handlerList === 'object' && Array.isAarry(handlerList))) {
        if (!target) {
          throw new Error('Insufficient Information to delegate event');
        }
        if (!name) {
          name = this.name;
        }
        handlerList = target.getEventHandlerList(name);
      }
      if (!target) {
        target = this.target;
      }
      this.path.push(target);
      replacementCompletionHandler = (function(_this) {
        return function() {
          if (postDelegationHandler) {
            return postDelegationHandler(_this);
          }
        };
      })(this);
      this.target = target;
      this.isDispatched = false;
      this._handlerList = handlerList;
      this._handlerIndex = 0;
      this._completionCallback = replacementCompletionHandler;
      return this.dispatch();
    };

    return Event;

  })(window.odse.EventEmitter);


  /*
    @class ErrorEvent
   */

  ErrorEvent = (function(superClass) {
    extend(ErrorEvent, superClass);

    ErrorEvent.isAsync = true;

    ErrorEvent.isSequencial = false;

    ErrorEvent.fallbackHandler = function(e) {
      console.log('Unmonitored Error');
      console.log("  Code: " + e.code);
      console.log("  Details: " + e.details);
      console.log("  Is Resolved: " + e.isResolved);
      return console.log("  Resolution: " + e.resolution);
    };

    function ErrorEvent(options) {
      ErrorEvent.__super__.constructor.call(this, options);
      this.code = options.data.code;
      this.details = options.data.details;
      this.isResolved = options.data.isResolved;
      this.isResolved || (this.isResolved = false);
      this.resolution = options.data.resolution;
      this.resolution || (this.resolution = null);
    }

    return ErrorEvent;

  })(window.odse.Event);

  window.odse.Event = window.odse.Event;

  window.odse.EventEmitter = window.odse.EventEmitter;

  window.odse.ErrorEvent = window.odse.ErrorEvent;

}).call(this);
